use clap::{
    App, Arg, ArgGroup
};
use crate::constants::{args::*, groups::*};

pub fn add_firewall_evasion_spoofing(app: App<'static>) -> App<'static> {
    app
        .help_heading(firewall_evasion_spoofing::NAME)
        .arg(
            Arg::new(fragment_packets::NAME)
                .short(fragment_packets::SHORT)
                .about(fragment_packets::HELP)
                .takes_value(false)
        )
        .arg(
            Arg::new(fragment_packets_mtu::NAME)
                .long(fragment_packets_mtu::LONG)
                .about(fragment_packets_mtu::HELP)
                .takes_value(true)
                .value_name(fragment_packets_mtu::VALUE_NAME)
        )
        .arg(
            Arg::new(decoy::NAME)
                .short(decoy::SHORT)
                .about(decoy::HELP)
                .takes_value(true)
                .value_name(decoy::VALUE_NAME)
                .value_delimiter(decoy::VALUE_DELIMITER)
        )
        .arg(
            Arg::new(ip_spoof::NAME)
                .short(ip_spoof::SHORT)
                .about(ip_spoof::HELP)
                .takes_value(true)
                .value_name(ip_spoof::VALUE_NAME)
        )
        .arg(
            Arg::new(use_interface::NAME)
                .short(use_interface::SHORT)
                .about(use_interface::HELP)
                .takes_value(true)
                .value_name(use_interface::VALUE_NAME)
        )
        .arg(
            Arg::new(use_port::NAME)
                .short(use_port::SHORT)
                .long(use_port::LONG)
                .about(use_port::HELP)
                .takes_value(true)
                .value_name(use_port::VALUE_NAME)
        )
        .arg(
            Arg::new(proxies::NAME)
                .long(proxies::LONG)
                .about(proxies::HELP)
                .takes_value(true)
                .value_name(proxies::VALUE_NAME)
                .value_delimiter(proxies::VALUE_DELIMITER)
        )
        .arg(
            Arg::new(data::NAME)
                .long(data::LONG)
                .about(data::HELP)
                .takes_value(true)
                .value_name(data::VALUE_NAME)
        )
        .arg(
            Arg::new(data_string::NAME)
                .long(data_string::LONG)
                .about(data_string::HELP)
                .takes_value(true)
                .value_name(data_string::VALUE_NAME)
        )
        .arg(
            Arg::new(data_length::NAME)
                .long(data_length::LONG)
                .about(data_length::HELP)
                .takes_value(true)
                .value_name(data_length::VALUE_NAME)
        )
        .arg(
            Arg::new(ip_options::NAME)
                .long(ip_options::LONG)
                .about(ip_options::HELP)
                .takes_value(true)
                .value_name(ip_options::VALUE_NAME)
        )
        .arg(
            Arg::new(ttl::NAME)
                .long(ttl::LONG)
                .about(ttl::HELP)
                .takes_value(true)
                .value_name(ttl::VALUE_NAME)
        )
        .arg(
            Arg::new(spoof_mac::NAME)
                .long(spoof_mac::LONG)
                .about(spoof_mac::HELP)
                .takes_value(true)
                .value_name(spoof_mac::VALUE_NAME)
        )
        .arg(
            Arg::new(badsum::NAME)
                .long(badsum::LONG)
                .about(badsum::HELP)
                .takes_value(false)
        )
        .group(
            ArgGroup::new(firewall_evasion_spoofing::NAME)
                .args(&[
                    fragment_packets::NAME, fragment_packets_mtu::NAME, decoy::NAME,
                    ip_spoof::NAME, use_interface::NAME, use_port::NAME, proxies::NAME,
                    data::NAME, data_string::NAME, data_length::NAME, ip_options::NAME,
                    ttl::NAME, spoof_mac::NAME, badsum::NAME
                ])
                .multiple(true)
        )
}